<html><head>
<title>A small tutorial on the Alignment API</title>
<script language="JavaScript">
function show(id) {
 var element = document.getElementById(id);
 element.style.display = "block";
}

function hide(id) {
 var element = document.getElementById(id);
 element.style.display = "none";
}
</script>

<link rel="stylesheet" type="text/css"
      href="base.css" />
<link rel="stylesheet" type="text/css"
      href="style.css" />
</head><body bgcolor="white">

<h1>A small tutorial on the Alignment API</h1>

<dl>

<dt>This version:</dt>
<dd>
http://alignapi.gforge.inria.fr/tutorial/
</dd>

<dt>Author:</dt>  
<dd>
<a href="http://exmo.inrialpes.fr/people/euzenat">Jérôme Euzenat</a>,
	INRIA Rhône-Alpes<br />
</dd>
</dl>

<hr />

<p>Here is a small tutorial for the alignment API. Since the API has no
dedicated GUI, most of the tutorial is based on command-lines
  invocations. Of course, it is not the natural way to use this API:
  it is made for being embedded in some application programme and we
  are working towards implementing an alignment server that can help
 programmes to use the API remotely. The complete tutorial is also
  available as a self-contained <a href="script.sh">script.sh</a>.</p>

<hr />
<h2>Preparation</h2>

<p>For running the alignment API, you must have a Java interpreter
available. We wil call it <tt>java</tt>.</p>
<p>Download the last version of the Alignement API from 
<a href="http://gforge.inria.fr/frs/?group_id=117">http://gforge.inria.fr/frs/?group_id=117</a>.
Unzip it and go to the created directory:
<div class="fragment"><pre>
$ mkdir alignapi
$ cd alignapi
$ unzip align*.zip
</pre></div></p>
<p>You can check that everything works by only typing 
<div class="fragment"><pre>
$ java -jar lib/procalign.jar --help
</pre></div>
<div class="button"><form><input type="button" value="Show
output" onclick="show('qu3')"/><input type="button" value="Hide
output" onclick="hide('qu3')"/></form></div>
<div class="explain" id="qu3">
<pre>
usage: Procalign [options] URI1 URI2
options are:
        --impl=className -i classname           Use the given alignment implementation.
        --renderer=className -r className       Specifies the alignment renderer
        --output=filename -o filename   Output the alignment in filename
        --params=filename -p filename   Reads parameters from filename
        --alignment=filename -a filename Start from an XML alignment file
        --threshold=double -t double    Filters the similarities under threshold
        --cutmethod=hard|perc|prop|best|span -T hard|perc|prop|best|span        method for computing the threshold
        --debug[=n] -d [n]              Report debug info at level n
        -Dparam=value                   Set parameter
        --help -h                       Print this message
</pre></div></p>
This should output the command line usage of the Procalign 
class. We do not detail it here, this tutorial will present
it entirelly.</p>
<p>You will then go to the tutorial directory by doing
<div class="fragment"><pre>
$ cd html/tutorial
</pre></div>
You can clean up previous trials by:
<div class="fragment"><pre>
$ rm results/
</pre></div>
</p>

<p>The goal of this tutorial is only to help you realize the
  possibilities of the Alignment API and implementation. It can be
  played by invoking each command line from the command-line
  interpreter. In this example we use the <tt>tcsh</tt> syntax but the main
  specific syntax is the first one:
<div class="fragment"><pre>
$ setenv CWD `pwd`
</pre></div>

which puts in variable <tt>$CWD</tt> the name of the current directory.</p>
<p>Beside a Java interpreter, if one wants to generate the HTML
  translations of the alignements, this can be done with the help of
  an XSLT 1.0 processor like <tt>xsltproc</tt>. Hence:
<div class="fragment"><pre>
$ xsltproc ../form-align.xsl results/file.rdf > results/file.html
</pre></div>

generates <tt>results/file.html</tt> from the alignment file <tt>results/file.rdf</tt>.</p>

<hr />
<h2>The data</h2>

<p>Your mission, if you accept it, will be to find the best alignment
  between two bibliographic ontologies. They can be seen here:
<dl>
<dt>edu.mit.visus.bibtex.owl</dt><dd>is a relatively faithfull
    transcription of BibTeX as an ontology. It can be seen here
    in <a href="edu.mit.visus.bibtex.owl">RDF/XML</a> or 
    <a href="edu.mit.visus.bibtex.html">HTML</a>.</dd>
<dt>myOnto.owl</dt><dd>is an extension of the previous one that
    contains a number of supplementary concepts. It can be seen here
    in <a href="myOnto.owl">RDF/XML</a> or 
    <a href="myOnto.html">HTML</a>.</dd>
</dl>
These two ontologies have been used for a few year in the <a href="oaei.ontologymatching.org">Ontology
Alignment Evaluation Initiative</a>
</p>

<hr />
<h2>Matching</h2>

<p>Let's try to match these two ontologies:
<div class="fragment"><pre>
$ java -jar ../../lib/procalign.jar file://localhost$CWD/myOnto.owl file://localhost$CWD/edu.mit.visus.bibtex.owl
</pre></div>
</p>

<p>The result is displayed on the standard output Since the output is
  too long we send it to a file by using the <tt>-o</tt> flag:
<div class="fragment"><pre>
$ java -jar ../../lib/procalign.jar file://localhost$CWD/myOnto.owl file://localhost$CWD/edu.mit.visus.bibtex.owl -o results/equal.rdf
</pre></div>
See the output in <a href="results/equal.rdf">RDF/XML</a> or <a href="results/equal.html">HTML</a>.</p>

<p>The result is expressed in the Alignment format.
This format, in RDF/XML, is made of a
header containing "metadata" about the alignment:
<div class="owl"><pre>
&lt;?xml version='1.0' encoding='utf-8' standalone='no'?>
&lt;rdf:RDF xmlns='http://knowledgeweb.semanticweb.org/heterogeneity/alignment'
         xml:base='http://knowledgeweb.semanticweb.org/heterogeneity/alignment'
         xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'
         xmlns:xsd='http://www.w3.org/2001/XMLSchema#'>
&lt;Alignment>
  &lt;xml>yes&lt;/xml>
  &lt;level>0&lt;/level>
  &lt;type>**&lt;/type>
  &lt;time>66&lt;/time>
  &lt;owl:Class rdf:about="Techreport">
    &lt;owl:equivalentClass rdf:resource="Techreport"/>
  &lt;/owl:Class>

  &lt;method>fr.inrialpes.exmo.align.impl.method.StringDistAlignment&lt;/method>
  &lt;onto1>file://localhost/JAVA/alignapi/html/tutorial/myOnto.owl&lt;/onto1>
  &lt;onto2>file://localhost/JAVA/alignapi/html/tutorial/edu.mit.visus.bibtex.owl&lt;/onto2>
  &lt;uri1>http://alignapi.gforge.inria.fr/tutorial/myOnto.owl&lt;/uri1>
  &lt;uri2>http://alignapi.gforge.inria.fr/tutorial/edu.mit.visus.bibtex.owl&lt;/uri2>
</pre></div>
and the corresponding set of correspondences:
<div class="owl"><pre>
  &lt;map>
    &lt;Cell>
      &lt;entity1 rdf:resource='http://alignapi.gforge.inria.fr/tutorial/myOnto.owl#Article'/>
      &lt;entity2 rdf:resource='http://alignapi.gforge.inria.fr/tutorial/edu.mit.visus.bibtex.owl#Article'/>
      &lt;measure rdf:datatype='http://www.w3.org/2001/XMLSchema#float'>1.0&lt;/measure>
      &lt;relation>=&lt;/relation>
    &lt;/Cell>
  &lt;/map>
</pre></div>
each correspondence is made of two references to the aligned entities,
the relation holding between the entities (<tt>=</tt>) and a confidence measure
(<tt>1.0</tt>) in this correspondence. Here, because the default method that
has been used for aligning the ontologies is so simple (it only
compares the labels of the entities and find that there is a
correspondence if their labels are equal), the correspondences are
always that simple. But it is too simple so we will use a more
sophisticated method based on an edit distance:</p>

<div class="fragment"><pre>
$ java -jar ../../lib/procalign.jar -i fr.inrialpes.exmo.align.impl.method.StringDistAlignment -DstringFunction=levenshteinDistance file://localhost$CWD/myOnto.owl file://localhost$CWD/edu.mit.visus.bibtex.owl -o results/levenshtein.rdf
</pre></div>
See the output in <a href="results/levenshtein.rdf">RDF/XML</a> or <a href="results/levenshtein.html">HTML</a>.</p>

<p>This is achieved by specifying the class of Alignment to be used
(through the <tt>-i</tt> switch) and the distance function to be used
(<tt>-DstringFunction=levenshteinDistance</tt>).</p>

<p>Look at the results: how are they different from before?
<div class="button"><form><input type="button" value="Show
Discussion" onclick="show('qu1')"/><input type="button" value="Hide
Discussion" onclick="hide('qu1')"/></form></div>
<div class="explain" id="qu1"><p>We can see that the
    correspondences now contain confidence factors different than <tt>1.0</tt>,
    they also match strings which are not the same and indeed far more
    correspondences are available.
</p></div></p>

<p>We do the same with another measure (smoaDistance):
<div class="fragment"><pre>
$ java -jar ../../lib/procalign.jar -i fr.inrialpes.exmo.align.impl.method.StringDistAlignment -DstringFunction=smoaDistance file://localhost$CWD/myOnto.owl file://localhost$CWD/edu.mit.visus.bibtex.owl -o results/SMOA.rdf
</pre></div>
</p>

<p><div class="logic"><p><b>More work:</b> you can apply other available alignments
  classes. Look in the
  <a
  href="../../src/fr/inrialpes/exmo/align/impl/method>"../../src/fr/inrialpes/exmo/align/impl/method</a>
  directory for more simple alignment methods. Also look in the
  <tt>StringDistAlignment</tt> class the possible values for <tt>stringFunction</tt>.</p></div></p>

<p><div class="logic"><b>Advanced:</b> You can also look at the instructions for
  installing WordNet and its Java interface and use a WordNet based
  distance provided with the API implementation by:
<div class="fragment"><pre>
$ java -jar ../../lib/alignwn.jar -i fr.inrialpes.exmo.align.ling.JWNLAlignment file://localhost$CWD/myOnto.owl file://localhost$CWD/edu.mit.visus.bibtex.owl -o results/jwnl.rdf
</pre></div>
See the output in <a href="jwnl.rdf">RDF/XML</a> or <a href="jwnl.html">HTML</a>.</p></div></p>

<hr />
<h2>Manipulating</h2>

<p>As can be seen there are some correspondences that do not really make
sense. Fortunatelly, they also have very low confidence level. It is
thus interesting to use a threshold for eliminating these
  values. Let's try a threshold of <tt>.33</tt> over the alignment
  (with the <tt>-t</tt> switch):
<div class="fragment"><pre>
$ java -jar ../../lib/procalign.jar file://localhost$CWD/myOnto.owl file://localhost$CWD/edu.mit.visus.bibtex.owl -i fr.inrialpes.exmo.align.impl.method.StringDistAlignment -DstringFunction=levenshteinDistance -t 0.33 -o results/levenshtein33.rdf
</pre></div>
See the output in <a href="results/levenshtein33.rdf">RDF/XML</a>
or <a href="results/levenshtein33.html">HTML</a>.</p>

<p>As expected we have suppressed some of these inaccurate
  correspondences. But did we also suppressed accurate ones?
<div class="button"><form><input type="button" value="Show
Discussion" onclick="show('qu4')"/><input type="button" value="Hide
Discussion" onclick="hide('qu4')"/></form></div>
<div class="explain" id="qu4"><p>
This operation has contributed eliminating a number of innacurate
correspondences like Journal-Conference or
Composite-Conference. However, there remains some unaccurate
correspondences like Institution-InCollection and Published-UnPublished!
</p></div></p>

<p>We can also apply this treatment to other methods available:
<div class="fragment"><pre>
$ java -jar ../../lib/procalign.jar -i fr.inrialpes.exmo.align.impl.method.StringDistAlignment -DstringFunction=smoaDistance file://localhost$CWD/myOnto.owl file://localhost$CWD/edu.mit.visus.bibtex.owl -t 0.5 -o results/SMOA5.rdf
</pre></div>
See the output in <a href="results/SMOA5.rdf">RDF/XML</a>
or <a href="results/SMOA5.html">HTML</a>.</p>

<p><b>Other manipulations:</b> It is possible to invert an alignement
  with the following command:
<div class="fragment"><pre>
$ java -cp ../../lib/procalign.jar fr.inrialpes.exmo.align.util.ParserPrinter -i results/SMOA5.rdf -o results/AOMS5.rdf
</pre></div>
See the output in <a href="results/AOMS5.rdf">RDF/XML</a>
or <a href="results/AOMS5.html">HTML</a>. The results is an alignement from
the source to the target.</p>

<p><div class="logic"><b>More work:</b>There is another switch (<tt>-T</tt>) in Procalign that
  specifies the way a threshold is applied (hard|perc|prop|best|span)
  the default being "hard". The curious reader can apply these and see
  the difference in results. How they work is explained in the
  Alignment API documentation.
</div></p>

<p><div class="logic"><b>More work:</b> Try to play with the
    thresholds in order to find the best values for
    levenshteinDistance and smoaDistance.
</div></p>

<hr />
<h2>Output</h2>

<p>Once a good alignment has been found, only half of the work has
  been done. In order to actually use our result it is necessary to
  transform it into some processable format. For instance, if one
  wants to merge two OWL ontologies, the alignment can be changed into
  as set of OWL "bridging" axioms. This is achieved by "rendering" the
  alignment in OWL (through the <tt>-r</tt> switch):
<div class="fragment"><pre>
$ java -cp ../../lib/procalign.jar fr.inrialpes.exmo.align.util.ParserPrinter results/SMOA5.rdf -r fr.inrialpes.exmo.align.impl.renderer.OWLAxiomsRendererVisitor
</pre></div>
The result is a set of OWL assertions of the form:
<div class="owl"><pre>
  &lt;owl:Class rdf:about="http://alignapi.gforge.inria.fr/tutorial/myOnto.owl#Techreport">
    &lt;owl:equivalentClass rdf:resource="http://alignapi.gforge.inria.fr/tutorial/edu.mit.visus.bibtex.owl#Techreport"/>
  &lt;/owl:Class>

  &lt;owl:ObjectProperty rdf:about="http://alignapi.gforge.inria.fr/tutorial/myOnto.owl#copyright">
    &lt;owl:equivalentProperty rdf:resource="http://alignapi.gforge.inria.fr/tutorial/edu.mit.visus.bibtex.owl#hasCopyright"/>
  &lt;/owl:ObjectProperty>
</pre></div>
</p>

<p>If one wants to use the alignments only for infering on instances
  without actually merging the classes, she can generate SWRL rules:
<div class="fragment"><pre>
$ java -cp ../../lib/procalign.jar fr.inrialpes.exmo.align.util.ParserPrinter results/SMOA5.rdf -r fr.inrialpes.exmo.align.impl.renderer.SWRLRendererVisitor
</pre></div>
which brings for the same assertions:
<div class="owl"><pre>
  &lt;ruleml:imp>
    &lt;ruleml:_body>
      &lt;swrl:classAtom>
        &lt;owllx:Class owllx:name="http://alignapi.gforge.inria.fr/tutorial/myOnto.owl#Techreport"/>
        &lt;ruleml:var>x&lt;/ruleml:var>
      &lt;/swrl:classAtom>
    &lt;/ruleml:_body>
    &lt;ruleml:_head>
      &lt;swrlx:classAtom>
        &lt;owllx:Class owllx:name="http://alignapi.gforge.inria.fr/tutorial/edu.mit.visus.bibtex.owl#hasCopyright"/>
        &lt;ruleml:var>x&lt;/ruleml:var>
      &lt;/swrl:classAtom>
    &lt;/ruleml:_head>
  &lt;/ruleml:imp>

  &lt;ruleml:imp>
    &lt;ruleml:_body>
      &lt;swrl:individualPropertyAtom swrlx:property="http://alignapi.gforge.inria.fr/tutorial/myOnto.owl#copyright"/>
        &lt;ruleml:var>x&lt;/ruleml:var>
        &lt;ruleml:var>y&lt;/ruleml:var>
      &lt;/swrl:individualPropertyAtom>
    &lt;/ruleml:_body>
    &lt;ruleml:_head>
      &lt;swrl:datavaluedPropertyAtom swrlx:property="http://alignapi.gforge.inria.fr/tutorial/edu.mit.visus.bibtex.owl#hasCopyright"/>
        &lt;ruleml:var>x&lt;/ruleml:var>
        &lt;ruleml:var>y&lt;/ruleml:var>
      &lt;/swrl:datavaluedPropertyAtom>
    &lt;/ruleml:_head>
  &lt;/ruleml:imp>
</pre></div>
</p>

<p>Exchanging data can also be achieved more simply 
through XLST transformations which will transform the OWL instance
  files from one ontology to another:
<div class="fragment"><pre>
$ java -cp ../../lib/procalign.jar fr.inrialpes.exmo.align.util.ParserPrinter dist.rdf -r fr.inrialpes.exmo.align.impl.renderer.XSLTRendererVisitor -o results/SMOA5.xsl
</pre></div>
this transformation can be applied to the data of <a href="data.xml">data.xml</a>:
<div class="fragment"><pre>
$ xsltproc results/SMOA5.xsl data.xml > results/data.xml
</pre></div>
for giving the <a href="results/data.xml">results/data.xml</a> file.
</p>

<hr />
<h2>Evaluating</h2>

<p>We will evaluate alignments by comparing them to some reference
  alignment which is supposed to express what is expected from an
  alignment of these two ontologies. The reference alignment is
  <a href="refalign.rdf">refalign.rdf</a>
  (or <a href="results/refalign.html">HTML</a>).</p>
<p>
<p>For evaluating we use another class than <tt>Procalign</tt>. It is called
  <tt>EvalAlign</tt> we should specify this to <tt>java</tt>. By default, it
  computes precision, recall and associated measures. It can be
  invoked this way:
<div class="fragment"><pre>
$ java -cp ../../lib/procalign.jar fr.inrialpes.exmo.align.util.EvalAlign -i fr.inrialpes.exmo.align.impl.eval.PRecEvaluator file://localhost$CWD/refalign.rdf file://localhost$CWD/results/equal.rdf
</pre></div>
The first argument is always the reference alignment, the second one
is the alignment to be evaluated. The result is given here:
<div class="owl"><pre>
&lt;?xml version='1.0' encoding='utf-8' standalone='yes'?>
&lt;rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'
  xmlns:map='http://www.atl.external.lmco.com/projects/ontology/ResultsOntology.n3#'>
  &lt;map:output rdf:about=''>
    &lt;map:reference rdf:resource="file://localhost/JAVA/alignapi/html/tutorial/results/refalign.rdf">
    &lt;map:input rdf:resource="file://localhost/JAVA/alignapi/html/tutorial/results/equal.rdf">
    &lt;map:precision>1.0&lt;/map:precision>
    &lt;map:recall>0.22916666666666666&lt;/map:recall>
    &lt;fallout>0.0&lt;/fallout>
    &lt;map:fMeasure>0.37288135593220334&lt;/map:fMeasure>
    &lt;map:oMeasure>0.22916666666666666&lt;/map:oMeasure>
    &lt;result>0.22916666666666666&lt;/result>
  &lt;/map:output>
&lt;/rdf:RDF>
</pre></div>
Of course, since that method only match objects with the same name, it
is accurate, yielding a high precision. However, it has poor recall.
</p>

<p>We can now evaluate the edit distance with its .33 threshold. What
 to expect from the evaluation of this alignment?
<div class="button"><form><input type="button" value="Show
Discussion" onclick="show('qu5')"/><input type="button" value="Hide
Discussion" onclick="hide('qu5')"/></form></div>
<div class="explain" id="qu5"><p>Since it returns more correspondences
    by loosening the constraints for being a correspondence, it is
    expected that the recall will increase at the expense of precision.
</p></div></p>

<p>We can see the results of:
<div class="fragment"><pre>
$ java -cp ../../lib/procalign.jar fr.inrialpes.exmo.align.util.EvalAlign -i fr.inrialpes.exmo.align.impl.eval.PRecEvaluator file://localhost$CWD/refalign.rdf file://localhost$CWD/results/levenshtein33.rdf
</pre></div>
<div class="button"><form><input type="button" value="Show
result" onclick="show('qu6')"/><input type="button" value="Hide
result" onclick="hide('qu6')"/></form></div>
<div class="explain" id="qu6"><pre>
&lt;?xml version='1.0' encoding='utf-8' standalone='yes'?>
&lt;rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'
  xmlns:map='http://www.atl.external.lmco.com/projects/ontology/ResultsOntology.n3#'>
  &lt;map:output rdf:about=''>
    &lt;map:reference rdf:resource="file://localhost/JAVA/alignapi/html/tutorial/results/refalign.rdf">
    &lt;map:input rdf:resource="file://localhost/JAVA/alignapi/html/tutorial/results/levenshtein33.rdf">
    &lt;map:precision>0.6811594202898551&lt;/map:precision>
    &lt;map:recall>0.9791666666666666&lt;/map:recall>
    &lt;fallout>0.3188405797101449&lt;/fallout>
    &lt;map:fMeasure>0.8034188034188035&lt;/map:fMeasure>
    &lt;map:oMeasure>0.5208333333333333&lt;/map:oMeasure>
    &lt;result>1.4374999999999998&lt;/result>
  &lt;/map:output>
&lt;/rdf:RDF>
</pre></div></p>

<p>It is possible to summarize these results by comparing them to
  each others. This can be achieved by the <tt>GroupEval</tt>
  class. This class can output several formats (by default html) and
  takes all the alignments in the subdirectories of the current
  directory. Here we only have the <tt>results</tt> directory:
<div class="fragment"><pre>
$ cp refalign.rdf results
$ java -cp ../../lib/procalign.jar fr.inrialpes.exmo.align.util.GroupEval -r refalign.rdf -l "refalign,equal,SMOA,SMOA5,levenshtein,levenshtein33" -c prf -o results/eval.html
</pre></div>
The results are displayed in
the <a href="results/eval.html">results/eval.html</a> file whose main
content is the table:<br />
<center>
<table border='2' frame='sides' rules='groups'>
<colgroup align='center' />
<colgroup align='center' span='2' />
<colgroup align='center' span='2' />
<colgroup align='center' span='2' />
<colgroup align='center' span='2' />
<colgroup align='center' span='2' />
<colgroup align='center' span='2' />
<thead valign='top'><tr><th>algo</th>
<th colspan='2'>refalign</th>
<th colspan='2'>equal</th>
<th colspan='2'>SMOA</th>
<th colspan='2'>SMOA5</th>
<th colspan='2'>levenshtein</th>
<th colspan='2'>levenshtein33</th>
</tr></thead><tbody><tr><td>test</td>
<td>Prec.</td>
<td>Rec.</td>
<td>Prec.</td>
<td>Rec.</td>
<td>Prec.</td>
<td>Rec.</td>
<td>Prec.</td>
<td>Rec.</td>
<td>Prec.</td>
<td>Rec.</td>
<td>Prec.</td>
<td>Rec.</td>
</tr></tbody><tbody>
<tr>
<td>results</td>
<td>1.00</td>
<td>1.00</td>
<td>1.00</td>
<td>0.23</td>
<td>0.56</td>
<td>0.98</td>
<td>0.69</td>
<td>0.96</td>
<td>0.53</td>
<td>1.00</td>
<td>0.68</td>
<td>0.98</td>
</tr>
<tr bgcolor="yellow"><td>H-mean</td><td>1.00</td>
<td>1.00</td>
<td>1.00</td>
<td>0.23</td>
<td>0.56</td>
<td>0.98</td>
<td>0.69</td>
<td>0.96</td>
<td>0.53</td>
<td>1.00</td>
<td>0.68</td>
<td>0.98</td>
</tr>
</tbody></table>
</center>
</p>

<!--div class="fragment"><pre>
$ java -jar ../../lib/Procalign.jar file://localhost$CWD/rdf/edu.umbc.ebiquity.publication.owl file://localhost$CWD/rdf/edu.mit.visus.bibtex.owl -i fr.inrialpes.exmo.align.impl.method.StringDistAlignment -DstringFunction=levenshteinDistance -DprintMatrix=1 -o /dev/null > matrix.tex
</pre></div-->

<div class="logic"><p><b>More work:</b> As you can see,
    the <tt>PRecEvaluator</tt> does not only provide precision and
    recall but also provides F-measure. F-measure is usually used as
    an "absolute" trade-off between precision and recall (i.e., the
    optimum F-measure is considered the best precision and
    recall). Can you establish this point for SMOA and levenshtein and
    tell which algorithm is more adapted?
</p></div>

<!--div class="logic"><p><b>More work:</b>If you want to compare several algorithms, there
  is another class, GroupAlign, that allows to run an
</p></div-->

<hr />
<h2>Embedding</h2>

<p>Of course, the goal of this API is not to be used at the command
  line level (even if it is very often very useful). So if you are
  ready for it, you can develop in Java your own application that take
  advantage of the API.</p>

<p>This should be possible to invoque it through:
<div class="fragment"><pre>
$ java -cp ../../lib/Procalign.jar MyApp file://localhost$CWD/rdf/edu.umbc.ebiquity.publication.owl file://localhost$CWD/rdf/edu.mit.visus.bibtex.owl
</pre></div></p>

<div class="logic"><p><b>More work:</b> Can you add a switch like the <tt>-i</tt> switch
  of <tt>Procalign</tt> so that the main class of the application can
  be passed at commant-line.
</p></div>

<p>




you can develop a specialized matching algorithm
  by subclassing the Java programs provided in 

<div class="logic"><p><b>More work:</b> Implement the F-measure optimization rule
  presented above so that you automatically select the threshold that
  maximizes F-measure.
</p></div>

<hr />
<h2>Further exercises</h2>

<p>
More info: <a href="http://alignapi.gforge.inria.fr">http://alignapi.gforge.inria.fr</a>
</p>

<!--
Planning:
- Alignment server (incl. DB storage, agents, WSDL service)
- Extensive composition operators (with comp. tables)
- Expressive alignment language (with SEKT/François Sharffe)
-->

<hr />
<h2>Acknowledgements</h2>

<p>The format of this tutorial has been shamelessly borrowed from Sean
  Bechhofer's <a href="http://owl.man.ac.uk/2005/07/sssw/">OWL tutorial</a>.</p>

<hr />
<center><small>http://alignapi.gforge.inria.fr/tutorial</small></center>
<hr />
$Id$
</body>
</html>
