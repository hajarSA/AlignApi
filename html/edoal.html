<html>
<head>
<title>EDOAL: Expressive and Declarative Ontology Alignment Language</title>
<!--style type="text/css">@import url(style.css);</style-->
<link rel="stylesheet" type="text/css" href="base.css" />
<link rel="stylesheet" type="text/css" href="style.css" />
</head>

<body>
[<a href="format.html">Alignment format</a>]
[<a href="./">API</a>]

<script type="text/javascript">/*<![CDATA[*/
/*
	Written by Jonathan Snook, http://www.snook.ca/jonathan
	Add-ons by Robert Nyman, http://www.robertnyman.com
	Author says "The credit comment is all it takes, no license. Go crazy with it!:-)"
	From http://www.robertnyman.com/2005/11/07/the-ultimate-getelementsbyclassname/
*/

var displayed = [];
displayed["fssyntax"] = 1;
displayed["rdfxml"] = 0;
displayed["n3"] = 0;
displayed["graph"] = 0;
displayed["owlxml"] = 0;

function primerOnLoad() {
  display('rdfxml', 'none');      set_display_by_id('hide-rs', 'none');       set_display_by_id('show-rs', '');
  display('n3', 'none');      set_display_by_id('hide-ts', 'none');       set_display_by_id('show-ts', '');
  display('graph', 'none');  set_display_by_id('hide-ms', 'none');       set_display_by_id('show-ms', '');
  display('owlxml', 'none');      set_display_by_id('hide-xs', 'none');       set_display_by_id('show-xs', '');
}

function display(syntax,status) {
  var howmany = 0;
  if (status=='none') {
    displayed[syntax] = 0; 
  } else { 
    displayed[syntax] = 1;
  }
  for ( i in displayed ) {
       howmany = howmany + displayed[i];
  }
  set_display_by_class('div',syntax,status);
  if ( howmany == 1 ) {
      set_display_by_class('b','syntax-head','none');
  } else {
      set_display_by_class('b','syntax-head','');
  }
}

function getElementsByClassName(oElm, strTagName, oClassNames){
	var arrElements = (! (! (strTagName == "*") || ! (oElm.all)))? oElm.all : oElm.getElementsByTagName(strTagName);
	var arrReturnElements = new Array();
	var arrRegExpClassNames = new Array();
	if(typeof oClassNames == "object"){
		for(var i=0; !(i>=oClassNames.length); i++){ /*>*/
			arrRegExpClassNames.push(new RegExp("(^|\\s)" + oClassNames[i].replace(/\-/g, "\\-") + "(\\s|$)"));
		}
	}
	else{
		arrRegExpClassNames.push(new RegExp("(^|\\s)" + oClassNames.replace(/\-/g, "\\-") + "(\\s|$)"));
	}
	var oElement;
	var bMatchesAll;
	for(var j=0; !(j>=arrElements.length); j++){ /*>*/
		oElement = arrElements[j];
		bMatchesAll = true;
		for(var k=0; !(k>=arrRegExpClassNames.length); k++){ /*>*/
			if(!arrRegExpClassNames[k].test(oElement.className)){
				bMatchesAll = false;
				break;
			}
		}
		if(bMatchesAll){
			arrReturnElements.push(oElement);
		}
	}
	return (arrReturnElements)
}

function set_display_by_class(el, cls, newValue) {
   var e = getElementsByClassName(document, el, cls);
   if (e != null) {
      for (var i=0; !(i>=e.length); i++) {
        e[i].style.display = newValue;
      }
   }
}

function set_display_by_id(id, newValue) {
   var e = document.getElementById(id);
   if (e != null) {
     e.style.display = newValue;
   }
}
/*]]>*/
</script>

<h1 class="titre">EDOAL: Expressive and Declarative Ontology Alignment Language</h1>

<p>
The Expressive and Declarative Ontology Alignment Language (EDOAL)
allows for representing
correspondences between the entities of different ontologies. Unlike
other formats, the alignment vocabulary allows to represent complex
correspondences allowing to precisely describe the relation between
the entities. The alignment vocabulary extends
the <a href="format.html">alignment format</a>.</p> 

<!--dl>
 <dt><a href="#sec:purpose">Purpose</a></dt>
 <dt><a href="#sec:features">Features</a></dt>
 <dt><a href="#sec:vocabulary">Vocabulary</a></dt>
  <dl>
   <dd><a href="#ssec:classes">Classes</a></dd>
   <dd><a href="#ssec:properties">Properties</a></dd>
   <dd><a href="#ssec:relations">Relations</a></dd>
   <dd><a href="#ssec:instances">Instances</a></dd>
  </dl>
 </dt>
 <dt><a href="#sec:examples">Examples</a></dt>
</dl-->

<h2 id="sec:purpose">Purpose</h2>

<p>Representing ontology alignments is the general purpose of this vocabulary. Particularly, it extends the ontology <a href="format.html">alignment format</a> in order to enable the representation of complex correspondences.</p>

<p>This format can be used for cases where expressing equivalence or subsumption between terms is not sufficient, when more precise relations need to be expressed. While term equivalence or subsumption might be enough for exchanging documents, more precise relations are needed to exchange and integrate data.</p>    

<p>This vocabulary was originally designed with the goal of representing patterns of correspondence between ontologies. It was since then both simplified and extended to obtain a minimal vocabulary on top of the alignment format, able to express all possible kinds of ontology alignments.</p>

<h2 id="sec:features">Features</h2>

The alignment vocabulary has the following features:
<ul>
 <li><b>Construction</b> of entities from other entities can be expressed through
 algebraic operators. Constructed entities allows to supply the
 shallowness of some ontologies.</li>
 <li><b>Restrictions</b> can be expressed on entities in order to narrow their scope. Narrowing the scope of an entity makes possible to better align this entity with the one corresponding in the other ontology.</li>
 <li><b>Transformations</b> of property values can be
 specified. Property values using different encoding or units can be
 aligned using transformations. The current version of Edoal only
 supports a limited kind of transformations. This will be improved soon.</li>
</ul>

<h2 id="sec:vocabulary">Vocabulary</h2>

<p>
In the alignment format, an alignment is a set of cells, each cell being a correspondence between two entities. The alignment vocabulary extend this scheme by allowing cells to contain compound entity descriptions. Each entity can be typed according to one of the following category: Class, Instance, Relation, Property. A relation corresponds to an object property in OWL, a property to a datatype property. Each entity can then be restricted, and transformation can be specified on propery values. 
</p>
<!--p>
The diagram below shows the vocabulary classes ???

<img src="img/alignment-vocabulary-classes.png" border="0" alt="">
</p-->

<p>
While <i>Alignment</i> and <i>Cell</i> are described by the <a href="format.html">alignment format</a>, we will focus here on the remaining classes.</p>

<h3 id="ssec:headers">Headers</h3>

<h4 id="ssec:namespaces">Namespaces</h4>
<p>
The namespace for the Alignment format is
still <tt>http://knowledgeweb.semanticweb.org/heterogeneity/alignment#</tt>
(usual prefix: align).
</p>
<p>
EDOAL's own namespace is <tt>http://ns.inria.org/edoal/1.0/</tt> (usual
prefix: edoal).
</p>
<p>
Comparators are taken from the W3C XPath functions
recommendation: <tt>http://www.w3.org/2005/xpath-functions</tt>
(usual prefix: functions).</p>

<h4 id="ssec:alignment">Alignment</h4>
<p>As specified by the alignment format, an alignment contains a set of correspondences (cells). Each cell can be linked to an alignment using the <i>map</i> property. The alignment moreover specifies the two aligned ontologies, and as exemplified in the code below.</p>

<div class="fragment"><pre>
&lt;?xml version='1.0' encoding='utf-8' standalone='no'?>
&lt;rdf:RDF xmlns='http://knowledgeweb.semanticweb.org/heterogeneity/alignment#'
         xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'
         xmlns:xsd='http://www.w3.org/2001/XMLSchema#'
         xmlns:align='http://knowledgeweb.semanticweb.org/heterogeneity/alignment#'>
&lt;Alignment>
  &lt;xml>yes&lt;/xml>
  &lt;level>0&lt;/level>
  &lt;type>**&lt;/type>
  &lt;align:method>fr.inrialpes.exmo.align.impl.method.StringDistAlignment&lt;/align:method>
  &lt;align:time>7&lt;/align:time>
  &lt;onto1>
    &lt;Ontology rdf:about="http://www.example.org/ontology1">
      &lt;location>file:examples/rdf/onto1.owl&lt;/location>
      &lt;formalism>
        &lt;Formalism align:name="OWL1.0" align:uri="http://www.w3.org/2002/07/owl#"/>
      &lt;/formalism>
    &lt;/Ontology>
  &lt;/onto1>
  &lt;onto2>
    &lt;Ontology rdf:about="http://www.example.org/ontology2">
      &lt;location>file:examples/rdf/onto2.owl&lt;/location>
      &lt;formalism>
        &lt;Formalism align:name="OWL1.0" align:uri="http://www.w3.org/2002/07/owl#"/>
      &lt;/formalism>
    &lt;/Ontology>
  &lt;/onto2>
...
</pre></div>

<p>Details on each property are available on the <a href="format.html">alignment format</a> page.</p>

<h3 id="ssec:entities">Entities</h3>

<p>
A quick overview of the implemented EDOAL API is provided here (<b>abstract</b>
classes are in bold and <i>interfaces</i> in italics):
<pre>
EDOALAlignment extends BasicAlignment

EDOALCell extends BasicCell

<b>Expression</b> implements <i>Clonable</i>
|- <a href="#ssec:classes"><b>ClassExpression</b></a>
|  |- ClassId implements <i>Id</i>
|  |- ClassConstruction
|  |- <b>ClassRestriction</b>
|     |- ClassDomainRestriction
|     |- ClassOccurenceRestriction
|     |- ClassTypeRestriction
|     |- ClassValueRestriction
|- <b>PathExpression</b> implements <i>ValueExpression</i>
|  |- <a href="#ssec:properties"><b>PropertyExpression</b></a>
|  |  |- PropertyId implements <i>Id</i>
|  |  |- PropertyConstruction
|  |  |- <b>PropertyRestriction</b>
|  |     |- PropertyDomainRestriction
|  |     |- PropertyTypeRestriction
|  |     |- PropertyValueRestriction
|  |- <a href="#ssec:relations"><b>RelationExpression</b></a>
|     |- RelationId implements <i>Id</i>
|     |- RelationConstruction
|     |- <b>RelationRestriction</b>
|        |- RelationCoDomainRestriction
|        |- RelationDomainRestriction
|- <a href="#ssec:instances"><b>InstanceExpression</b></a>
   |- InstanceId implements <i>Id</i>

Value implements <i>ValueExpression</i>
Apply implements <i>ValueExpression</i>

Transformation

TransfService implements <i>Clonable</i>

<a href="sec:patterns">Variable</a>

Comparator

Datatype
</pre>
</p>

<h4 id="ssec:classes">Classes</h4>
<p>Class entities can be constructed using one of the three operators <i>and, or,
not</i>.<ul>
  <li><i>and</i> represents the interesection of the classes in the
  expression</li>
  <li><i>or</i> represents the union of the classes in the expression</li>

  <li><i>not</i> represents the negation of a given class.</li>
</ul>
A class can be defined using its URI or a restriction. Restrictions are defined by giving an <i>attribute</i> (relation or property), a <i>comparator</i> defining the relation to a <i>value</i>.</p>

<div class="fragment"><pre>
<u>classexpr</u> ::= &lt;Class rdf:about=" <u>URI</u> "/>
            | &lt;Class> <u>classconst</u> &lt;/Class>
            | &lt;AttributeOccurenceRestriction> <u>onatt</u> <u>comp</u> <u>INTEGER</u> &lt;/AttributeOccurenceRestriction>
            | &lt;AttributeDomainRestriction> <u>onatt</u> <u>classrest</u> &lt;/AttributeDomainRestriction>
            | &lt;AttributeTypeRestriction> <u>onatt</u> <u>typerest</u> &lt;/AttributeTypeRestriction>
            | &lt;AttributeValueRestriction> <u>onatt</u> <u>comp</u> (&lt;value><u>instexpr</u>&lt;/value>|<u>val</u>) &lt;/AttributeValueRestriction>

<u>classconst</u> ::= &lt;and rdf:parseType="Collection"> <u>classexpr</u>+&lt;/and>
             | &lt;or rdf:parseType="Collection"> <u>classexpr</u>+ &lt;/or>
             | &lt;not> <u>classexpr</u> &lt;/not>
</pre></div>

<p>This grammar relies on base values described in the following
  table:</p>

<div class="fragment"><pre>
<u>entity</u> ::= <u>instexpr</u> | <u>classexpr</u> | <u>attexpr</u>

<u>attexpr</u> ::= <u>propexpr</u> | <u>relexpr</u>

<u>onatt</u> ::= &lt;onAttribute> <u>attexpr</u> &lt;/onAttribute>

<u>val</u> ::= &lt;value> <u>value</u> &lt;/value> 

<u>typerest</u> ::= <!--&lt;all> <u>type</u> &lt;/all> | &lt;exists> <u>type</u> &lt;/exists> | -->&lt;type> <u>type</u> &lt;/type>

<u>type</u> ::= &lt;Datatype rdf:about=" <u>URI</u> " />

<u>classrest</u> ::= &lt;all> <u>classexpr</u> &lt;/all> | &lt;exists> <u>classexpr</u> &lt;/exists> | &lt;class> <u>classexpre</u> &lt;/class>

<u>comp</u> ::= &lt;comparator rdf:resource=" <u>URI</u> "/>

<u>value</u> ::= &lt;Literal {type=" <u>URI</u> "} string=" <u>STRING</u> " /> | <u>instepr</u> | <u>attrexpr</u> 
        | &lt;Apply operator=" <u>URI</u> "> &lt;arguments rdf:parseType="Collection"><u>value</u>*&lt;/arguments> &lt;/Apply>
</pre></div>


<p>Comparators are taken from the XPath function specification [<a href="http://www.w3.org/TR/xpath-functions">1</a>].</p>

<h4 id="ssec:properties">Properties</h4>
<p>Properties entities can be constructed using one of the operators <i>and, or,
not</i> and <i>compose</i>.
Property values can be transformed by applying a <i>Transformation</i> function. </p>

<div class="fragment"><pre>
<u>propexpr</u> ::= &lt;Property rdf:about=" <u>URI</u> "/> 
           | &lt;Property> <u>propconst</u>+ &lt;/Property> 
           | &lt;PropertyDomainRestriction> &lt;class> <u>classexpr</u> &lt;/class> &lt;/PropertyDomainRestriction> 
           | &lt;PropertyTypeRestriction> <u>typerest</u> &lt;/PropertyTypeRestriction> 
           | &lt;PropertyValueRestriction> <u>comp</u> <u>val</u> &lt;/PropertyValueRestriction><!--
           | <u>transf</u>-->

<u>propconst</u> ::= &lt;and rdf:parseType="Collection"> <u>propexpr</u>+ &lt;/and> 
            | &lt;or rdf:parseType="Collection"> <u>propexpr</u>+ &lt;/or> 
            | &lt;not> <u>propexpr</u> &lt;/not> 
            | &lt;compose> <u>relexpr</u>* <u>propexpr</u> &lt;/compose>

</pre></div>

<!--div class="fragment"><pre>
transformation ::= &lt;Transformation>
                    xpath-transformation
                   &lt;/Transformation>
                   | &lt;Transformation>            
                      &lt;transformation rdf:resource="uri"/>
                      &lt;parameters>
                       &lt;rdf:Seq>
                      	&lt;rdf:li />*	
                       &lt;/rdf:Seq>
                      &lt;/parameters>                  
                     &lt;/Transformation>
</pre></div-->

<!--p>Transformations are of two kinds, either XPath transformation functions can be used, or other transformation services can be invoked, for example for dynamic transformations like currency conversions (see <a href="#sec:examples">examples</a>).</p-->

<h4 id="ssec:relations">Relations</h4>
<p>Relations correspond to object properties in OWL. Relation entities can be constructed using the operators <i>and, or,
not, compose</i>, but also <i>inverse, transitive, reflexive,</i> and <i>symmetric</i>. Like properties they can also be composed in a path of relations using <i>first</i> and <i>next</i>. Relations <i>domain</i> and <i>range</i> can be restricted.</p>

<div class="fragment"><pre>
<u>relexpr</u> ::= &lt;Relation rdf:about=" <u>URI</u> "/> 
         | &lt;Relation> <u>relconst</u>+ &lt;/Relation> 
         | &lt;RelationDomainRestriction> &lt;class> <u>classexpr</u> &lt;/class> &lt;/RelationDomainRestriction
         | &lt;RelationCoDomainRestriction> &lt;class> <u>classexpr</u> &lt;/class> &lt;/RelationCoDomainRestriction 

<u>relconst</u> ::= &lt;and rdf:parseType="Collection"> <u>relexpr</u>+ &lt;/and> 
           | &lt;or rdf:parseType="Collection"> <u>relexpr</u>+ &lt;/or> 
           | &lt;not> <u>relexpr</u> &lt;/not> 
           | &lt;compose> <u>relexpr</u>+ &lt;/compose>
           | &lt;inverse> <u>relexpr</u> &lt;/inverse>
           | &lt;symmetric> <u>relexpr</u> &lt;/symmetric> 
           | &lt;transitive> <u>relexpr</u> &lt;/transitive> 
           | &lt;reflexive> <u>relexpr</u> &lt;/reflexive>
</pre></div>

<h4 id="ssec:instances">Instances</h4>
<p>Instances are always single entities refering to an individual
  through its URI.</p>
<div class="fragment"><pre>
<u>instance</u> ::= &lt;Instance rdf:about=" <u>URI</u> "/>
</pre></div>

<h2 id="sec:examples">Examples</h2>

<p>The best examples are the alignment files found in the
  "examples/omwg" directory of the Alignment API release zip.</p>

<p>The following exmples illustrate various kids of usage of the vocabulary.</p>

<div class="syntaxmenu">
<p>The buttons below can be used to show or hide the available syntaxes.</p><form action=""><p>
<input id="hide-rs" onclick="display('rdfxml', 'none');      set_display_by_id('hide-rs', 'none');       set_display_by_id('show-rs', '');" type="button" value="Hide RDF/XML Syntax" />
<input id="show-rs" onclick="display('rdfxml', '');      set_display_by_id('hide-rs', '');       set_display_by_id('show-rs', 'none');" style="display:none" type="button" value="Show RDF/XML Syntax" />
<input id="hide-ts" onclick="display('n3', 'none');      set_display_by_id('hide-ts', 'none');       set_display_by_id('show-ts', '');" type="button" value="Hide N3 Syntax" />
<input id="show-ts" onclick="display('n3', '');      set_display_by_id('hide-ts', '');       set_display_by_id('show-ts', 'none');" style="display:none" type="button" value="Show N3 Syntax" />
<input id="hide-ms" onclick="display('graph', 'none');            set_display_by_id('hide-ms', 'none');             set_display_by_id('show-ms', '');" type="button" value="Hide Graph" />
<input id="show-ms" onclick="display('graph','');      set_display_by_id('hide-ms', '');       set_display_by_id('show-ms', 'none');" style="display:none" type="button" value="Show Graph" />
</p></form>
</div>

<p>
In case of conflict, the RDF/XML syntax is the authoritative one.
This is also the one for which we have developed parsers and renderers.
However, we are glad that you report errors in the other syntaxes as well.
</p>

<h3 id="ssec:ex1">Class partition</h3>

<p>This example shows how to express a correspondence between a class in one ontology corresponding to a set of classes in the other ontology. In order to graps the precise correspondence, the one class is partitioned according to the value of one of its attributes. In this example one ontology has a class LED which has a property color, while the other ontology has three classes RedLED, BlueLED, and GreenLED. The LED class is aligned with the three corresponding classes by specifying a restriction of its scope to the corresponding value of the <i>color</i> attribute.</p>

<div class="rdfxml"><div class="exampleheader">RDF/XML Syntax</div>
<div class="fragment">
<pre>
&lt;align:Cell rdf:about="#cell1">
  &lt;align:entity1>
    &lt;edoal:Class>
      &lt;edoal:and rdf:parseType="Collection">
        &lt;edoal:Class rdf:about="&O1;LED" />
        &lt;edoal:AttributeValueRestriction>
          &lt;edoal:onAttribute>
            &lt;edoal:Relation rdf:about="&O1;hasColor" />
          &lt;/edoal:onAttribute>
	  &lt;edoal:comparator rdf:resource="&xsd;equals" />
          &lt;edoal:value>&lt;edoal:Instance rdf:about="&O1;Blue"/>&lt;/edoal:value>
        &lt;/edoal:AttributeValueRestriction>
      &lt;/edoal:and>
    &lt;/edoal:Class>
  &lt;/align:entity1>
  &lt;align:entity2>&lt;edoal:Class rdf:about="&O2;BlueLED" />&lt;/align:entity2>
  &lt;align:relation>=&lt;/align:relation>
&lt;/align:Cell>

&lt;align:Cell rdf:about="#cell2">
  &lt;align:entity1>
    &lt;edoal:Class>
      &lt;edoal:and rdf:parseType="Collection">
        &lt;edoal:Class rdf:about="&O1;LED" />
        &lt;edoal:AttributeValueRestriction>
          &lt;edoal:onAttribute>
            &lt;edoal:Relation rdf:about="&O1;hasColor" />
          &lt;/edoal:onAttribute>
	  &lt;edoal:comparator rdf:resource="&xsd;equals" />
          &lt;edoal:value>&lt;edoal:Instance rdf:about="&O1;Red"/>&lt;/edoal:value>
        &lt;/edoal:AttributeValueRestriction>
      &lt;/edoal:and>
    &lt;/edoal:Class>
  &lt;/align:entity1>
  &lt;align:entity2>&lt;edoal:Class rdf:about="&O2;RedLED" />&lt;/align:entity2>
  &lt;align:relation>=&lt;/align:relation>
&lt;/align:Cell>

&lt;align:Cell rdf:about="#cell3">
  &lt;align:entity1>
    &lt;edoal:Class>
      &lt;edoal:and rdf:parseType="Collection">
        &lt;edoal:Class rdf:about="&O1;LED" />
        &lt;edoal:AttributeValueRestriction>
          &lt;edoal:onAttribute>
            &lt;edoal:Relation rdf:about="&O1;hasColor" />
          &lt;/edoal:onAttribute>
	  &lt;edoal:comparator rdf:resource="&xsd;equals" />
          &lt;edoal:value>&lt;edoal:Instance rdf:about="&O1;Green"/>&lt;/edoal:value>
        &lt;/edoal:AttributeValueRestriction>
      &lt;/edoal:and>
    &lt;/edoal:Class>
  &lt;/align:entity1>
  &lt;align:entity2>&lt;edoal:Class rdf:about="&O2;GreenLED" />&lt;/align:entity2>
  &lt;align:relation>=&lt;/align:relation>
&lt;/align:Cell>
</pre>
</div>
</div>
<div class="n3"><div class="exampleheader">N3 Syntax</div>
<div class="detail" id="ex1n3"><pre>
O1:LED a edoal:Class;
O1:hasColor a edoal:Relation.
O1:Blue a edoal:Instance.
O2:BlueLED a edoal:Class.
:cell1 a align:Cell;
	align:entity1 [
		edoal:and [
			edoal:onProperty O1:hasColor;
			edoal:comparator function:equals;
			edoal:value O1:Blue.
		];
		edoal:and O1:LED.
	align:entity2 O2:BlueLED.
O1:Red a edoal:Instance.
O2:RedLED a edoal:Class.
:cell2 a align:Cell;
	align:entity1  [
		edoal:and [
			edoal:onProperty O1:hasColor;
			edoal:comparator function:equals;
			edoal:value O1:Red.
		];
		edoal:and O1:LED.
	align:entity2 O2:RedLED.
O1:Green a edoal:Instance.
O2:GreenLED a edoal:Class.
:cell3 a align:Cell;
	align:entity1  [
		edoal:and [
			edoal:onProperty O1:hasColor;
			edoal:comparator function:equals;
			edoal:value O1:Green.
		];
		edoal:and O1:LED.
	align:entity2 O2:GreenLED.
</pre></div>
</div>
<div class="graph"><div class="exampleheader">Graph</div>
<center>
<!--<img src="graph-partition-pattern-alignment-representation-small.png" border="0" alt="">-->
<object type="image/svg+xml" data="img/graph-partition-pattern-alignment-representation-corrected.svg" width="600" height="300">
</object> 
</center>
</div>

<h3 id="ssec:ex2">Property value transformation (XPath function)</h3>

<p>This exemple shows how to use a transformation between property values. Two cases can be considered: static transformations such as unit conversion, and transformations which vary over time such as currency conversions. This example illustrates a static conversion from pounds to kilograms using a XPath function.</p>

<div class="rdfxml"><div class="exampleheader">RDF/XML Syntax</div>
<p>We give two valid version of this correspondence depending on if
  the correspondence apply to the two properties (version 1) or the
  bearer of the transformed properties (version 2).
<div class="fragment">
<pre>
&lt;align:Cell rdf:about="#cell">
  &lt;align:entity1>&lt;edoal:Property rdf:about="&O1;hasWeight" />&lt;/align:entity1>
  &lt;align:entity2>&lt;edoal:Property rdf:about="&O2;weight" />&lt;/align:entity2>
  &lt;align:relation>=&lt;/align:relation>
  &lt;edoal:transformation>
    &lt;edoal:Transformation edoal:type="o-">
      &lt;edoal:entity1>
	&lt;edoal:Property>&lt;edoal:compose rdf:parseType="Collection"/>&lt;/edoal:Property>
      &lt;/edoal:entity1>
      &lt;edoal:entity2>
	&lt;edoal:Apply edoal:operator="&fn;safe-divide">
	  &lt;edoal:arguments rdf:parseType="Collection">
            &lt;edoal:Property>&lt;edoal:compose rdf:parseType="Collection"/>&lt;/edoal:Property>
            &lt;edoal:Literal edoal:type="&xsd;float" edoal:string="2.679229" />
	  &lt;/edoal:arguments>
	&lt;/edoal:Apply>
      &lt;/edoal:entity2>
    &lt;/edoal:Transformation>
  &lt;/edoal:transformation>
&lt;/align:Cell>
</pre>
</div>
<div class="fragment">
<pre>
&lt;align:Cell rdf:about="#cell">
  &lt;align:entity1>&lt;edoal:Class rdf:about="&O1;Person" />&lt;/align:entity1>
  &lt;align:entity2>&lt;edoal:Class rdf:about="&O2;Patient" />&lt;/align:entity2>
  &lt;align:relation>=&lt;/align:relation>
  &lt;edoal:transformation>
    &lt;edoal:Transformation edoal:type="o-">
      &lt;edoal:entity1>&lt;edoal:Property rdf:about="&O1;hasWeight" />&lt;/edoal:entity1>
      &lt;edoal:entity2>
	&lt;edoal:Apply edoal:operator="&fn;safe-divide">
	  &lt;edoal:arguments rdf:parseType="Collection">
            &lt;edoal:Property rdf:about="&O2;weight" />
            &lt;edoal:Literal edoal:type="&xsd;float" edoal:string="2.679229" />
	  &lt;/edoal:arguments>
	&lt;/edoal:Apply>
      &lt;/edoal:entity2>
    &lt;/edoal:Transformation>
  &lt;/edoal:transformation>
&lt;/align:Cell>
</pre>
</div>
</div>
<div class="n3"><div class="exampleheader">N3 Syntax</div>
<div class="detail" id="ex2n3"><pre>
01:hasWeight a edoal:Property.
O2:weight a edoal:Property.
:cell a align:Cell;
	align:entity1 O1:hasWeight;
	align:entity2 [
		a Transformation;
		fn:safe-divide [
			a rdf:Seq;
			rdf:li O2:weight;
			rdf:li 2.679229.
		].
	].
</pre></div>
</div>
<div class="graph"><div class="exampleheader">Graph</div>
<center>
<!--<img src="graph-property-value-xpath-transformation-small.png" border="0" alt="RDF graph of a property value transformation using a XPath function">-->
<object data="img/graph-property-value-xpath-transformation.svg" type="image/svg+xml" width="500" height="70">
</object>
</center>
</div>

<h3 id="ssec:ex3">Property value transformation (other service)</h3>

<p>This example illustrates the conversion between two currencies. A transformation service is specified.</p>

<div class="rdfxml"><div class="exampleheader">RDF/XML Syntax</div>
<div class="fragment"><pre>
&lt;align:Cell>
  &lt;align:entity1>&lt;edoal:Property rdf:about="&O1;price" />&lt;/align:entity1>
  &lt;align:entity2>&lt;edoal:Property rdf:about="&O2;hasPrice" />&lt;/align:entity2>
  &lt;align:relation>=&lt;/align:relation>
  &lt;edoal:transformation>
    &lt;edoal:Transformation edoal:type="o-">
      &lt;edoal:entity1>
	&lt;edoal:Property>&lt;edoal:compose rdf:parseType="Collection"/>&lt;/edoal:Property>
      &lt;/edoal:entity1>
      &lt;edoal:entity2>
	&lt;edoal:Apply edoal:operator="http://www.google.com/finance/converter">
	  &lt;edoal:arguments rdf:parseType="Collection">
            &lt;edoal:Property>&lt;edoal:compose rdf:parseType="Collection"/>&lt;/edoal:Property>
            &lt;edoal:Literal edoal:value="EUR" />
            &lt;edoal:Literal edoal:value="CNY" />
	  &lt;/edoal:arguments>
	&lt;/edoal:Apply>
      &lt;/edoal:entity2>
    &lt;/edoal:Transformation>
  &lt;/edoal:transformation>
</pre>
</div>
</div>
<div class="n3"><div class="exampleheader">N3 Syntax</div>
<div class="detail" id="ex3n3"><pre>
O1:price a edoal:Property.
O2:hasPrice a edoal:Property.
:cell a align:Cell;
	align:entity1 [
			edoal:function &lt;http://www.google.com/finance/converter?>;
			edoal:parameters [ rdf:li O1:price;
			  rdf:li "from=EUR";
			  rdf:li "to=CNY".
		   ].
	];
	align:entity2 O2:hasPrice.
</pre></div>
</div>
<div class="graph"><div class="exampleheader">Graph</div>
<center>
<!--<img src="graph-property-value-transformation-small.png" border="0" alt="Property data transformation RDF graph">-->
<object data="img/graph-property-value-transformation.svg" type="image/svg+xml" width="600" height="150">
</object>
</center>
</div>
<!--<img src="property-data-transformation-small.png" border="0" alt="Property value transformation pattern">-->

<h3 id="ssec:ex4">Class with attribute value restriction</h3>

<p>
This alignment pattern makes use of three variables. Var3 is a
property variable representing a property having in its domain the
class identified by the variable Var1. 
Moreover, the property Var3 has an integer value.
This pattern thus captures all correspondences between two classes, the scope of one class being restricted to only those instances having a specific value (not specified by the pattern) for one of its property whith datatype "integer".</p>

<div class="rdfxml"><div class="exampleheader">RDF/XML Syntax</div>
<div class="fragment">
<pre>
&lt;align:Cell rdf:about="#Cell1">
  &lt;align:entity1>
    &lt;edoal:Class>
      &lt;edoal:and rdf:parseType="Collection">
        &lt;edoal:Class edoal:var="#var1" />
        &lt;edoal:AttributeTypeRestriction>
          &lt;edoal:onProperty>
            &lt;edoal:PropertyDomainRestriction edoal:var="#var3">
              &lt;edoal:class>
                &lt;edoal:Class edoal:var="#var1" />
              &lt;/edoal:class>
            &lt;/edoal:PropertyDomainRestriction>
          &lt;/edoal:onProperty>
          &lt;edoal:type>&lt;edoal:Datatype rdf:about="&xsd;integer" />&lt;/edoal:type>
        &lt;/edoal:AttributeTypeRestriction>
      &lt;/edoal:and>
    &lt;/edoal:Class>
  &lt;/align:entity1>
  &lt;align:entity2>
    &lt;edoal:Class edoal:var="#var2" />
  &lt;/align:entity2>
  &lt;align:relation>=&lt;/align:relation>
&lt;/align:Cell>
</pre>
</div>
</div>
<div class="n3"><div class="exampleheader">N3 Syntax</div>
<div class="detail" id="ex4n3"><pre>
:var1 a edoal:Variable;
	a edoal:Class.
:var2 a edoal:Variable;
	a edoal:Class;
:var3 a edoal:Variable;
	a edoal:Property;
	edoal:and [
		edoal:domainRestriction :var1.
	].
	edoal:and [
		edoal:typeRestriction &lt;http://www.w3.org/2001/XMLSchema#integer>.
	].
:Cell1 a align:Cell;
	align:entity1 [
		edoal:and :var1;
		edoal:and [
			a edoal:Restriction;
			edoal:onProperty :var3.
		].
	].
	align:entity2 :var2.
</pre></div>
</div>
<div class="graph"><div class="exampleheader">Graph</div>
<center>
<object data="img/graph-class-with-attribute-value-restriction.svg" type="image/svg+xml" width="530" height="120">
</object>
</center>
</div>

<h2 id="sec:patterns">EDOAL Pattern</h2>

<p>
EDOAL also contains a pattern language with allows for expressing
generalised correspondences in which entities can be abstract. This
language is not very different from EDOAL (beside its introduction of
variables which are already present in the previous example).
</p>
<p>
It will be released at a later stage. Ask Fran&ccedil;ois Scharffe
for a more complete description of the EDOAL Pattern language.
</p>

<!--h3 id="ssec:variables">Variables</h3>
<p>Variables are useful to represent alignment patterns. (see <a href="#ssec:ex4">Example 4</a>) A variable can be linked to an identifier string, and can be bounded to an entity.</p>
<div class="fragment"><pre>
variable ::= &lt;Variable>
              &lt;var_id>string&lt;/var_id>
              &lt;var_binding rdf:resource="uri"/>
             &lt;/Variable>
</pre></div-->

<h2>History</h2>

<p>
This language has been first designed by Fran&ccedil;ois Scharffe as
the SEKT Mapping language.
</p>
<p>
It then became the <a href="http://www.omwg.org/TR/d7/rdf-xml-syntax/">OMWG Ontology Mapping language</a> developed under the
Sourceforge mappingapi project
(<a href="http://sourceforge.net/projects/mediation/">http://sourceforge.net/projects/mediation/</a>). This
language was further described by Fran&ccedil;ois Scharffe,
J&eacute;r&ocirc;me Euzenat and Antoine Zimmermann
in <a href="ftp://ftp.inrialpes.fr/pub/exmo/reports/kweb-2210.pdf">Knowledge
web deliverable 2.2.10</a>, in particular through the semantics of
the language. Its implementation was also reengineered as an extension
of the <a href="format.html">alignment format</a> so that it could be
manipulated through the Alignment API tools (starting version 3.1).
</p>
<p>
It has now been redesigned and reimplemented under the name of
EDOAL. It is a plain component of the Alignment API and is maintained
together with it.
</p>

<h2>Thanks</h2>

<p>
Thanks to <a href="http://www.snook.ca/jonathan">Jonathan Snook</a>
and <a href="http://www.robertnyman.com">Robert Nyman</a> for the
syntax toggling scripts borrowed from the OWL Recommendation web page.
<a href="http://www.robertnyman.com/2005/11/07/the-ultimate-getelementsbyclassname/">http://www.robertnyman.com/2005/11/07/the-ultimate-getelementsbyclassname/</a>.
</p> 

<address>
<small>
<hr />
<center>http://alignapi.gforge.inria.fr/edoal.html</center>
<hr />
$Id$
</small>
</address>
</body>
</html>
