<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Embedding the Alignment API</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
<link rel="stylesheet" type="text/css" href="../../base.css" />
<link rel="stylesheet" type="text/css" href="../../style.css" />
<script type="text/javascript">
<!--
function show(id) {
	var element = document.getElementById(id);
	element.style.display = "block";
}
function hide(id) {
	var element = document.getElementById(id);
	element.style.display = "none";
}
-->
</script>
<style type="text/css">
<!--
div.logic {
	padding-left: 5px;
	padding-right: 5px;
	margin-top: 10px;
	margin-bottom: 10px;
}
-->
</style>
</head>
<body style="background-color: #FFFFFF;">

<h1>Embedding the Alignment <abbr title="Application Programming Interface">API</abbr></h1>

<dl>
<dt>This version:</dt>
<dd>http://alignapi.gforge.inria.fr/tutorial/tutorial3/embed.html</dd>
<dt>Author:</dt>
<dd><a href="http://exmo.inrialpes.fr/people/euzenat">J&eacute;r&ocirc;me Euzenat</a>, INRIA &amp; LIG
</dd>
</dl>

<p style="border-bottom: 2px solid #AAAAAA; border-top: 2px solid
	  #AAAAAA; padding-top: 15px; padding-bottom: 15px;">Here is a
  tutorial for embedding the alignment <abbr>API</abbr> within your
	  own applications. 
</p>

<p>Of course, the goal of the Alignment <abbr>API</abbr> is not to be used at the command line level (even if it can be very useful). So if you are ready for it, you can develop in Java your own application that takes advantage of the <abbr>API</abbr>.</p>

<h2>Starting point</h2>
	
<p>A skeleton of program using the Alignment <abbr>API</abbr> is <a href="Skeleton.java">Skeleton.java</a>. It can be compiled by invoking:</p>
<div class="fragment">
$ javac -classpath ../../lib/align.jar:../../lib/procalign.jar -d results Skeleton.java
</div>
<p>and run by:</p>
<div class="fragment">
$ java -cp ../../lib/Procalign.jar:results Skeleton file://$CWD/myOnto.owl file://$CWD/edu.mit.visus.bibtex.owl
</div>

<p>Now considering the <abbr>API</abbr> (that can be consulted through its
 thin <a href="../../../javadoc/org/semanticweb/owl/align/Alignment.html">Javadoc</a>
 for instance), can you modify the Skeleton program so that it performs the following:</p>
<ul>
<li>Run two different alignment methods (e.g., ngram distance and smoa);</li>
<li>Merge the two results;</li>
<li>Trim at various thresholds;</li>
<li>Evaluate them against the reference alignment and choose the one with the best F-Measure;</li>
<li>Displays it as <acronym title="The web ontology language OWL">OWL</acronym> axioms.</li>
</ul>

<p>Of course, you can do it progressively.</p>

<h2>Call an alignment method</h2>

<p>
Matching two ontologies is achieved with three steps:
<ul>
<li>creating an instance of the class implementing the expected method
  (implementing the <tt>AlignmentProcess</tt> interface);</li>
<li>providing the two ontologies to match to this instance (<tt>init</tt>);</li>
<li>calling the matching method (<tt>align</tt>).</li>
</ul>
The matching method takes two arguments: an eventual alignment to
improve on (which can be null) a set of parameters
</p>

<p>
Below, two different methods (<tt>StringDistAlignment</tt> with two
different <tt>stringFunction</tt> parameters) are instantiated and run:
<div class="fragment">
  // Run two different alignment methods (e.g., ngram distance and smoa)
  AlignmentProcess a1 = new StringDistAlignment();
  params.setParameter("stringFunction","smoaDistance");
  a1.init ( onto1, onto2 );
  a1.align( (Alignment)null, params );
  AlignmentProcess a2 = new StringDistAlignment();
  a2.init ( onto1, onto2 );
  params = new BasicParameters();
  params.setParameter("stringFunction","ngramDistance");
  a2.align( (Alignment)null, params );
</div>
After this step, the two matching methods have been processed and the
result is available within the alignment instances (<tt>a1</tt>
and <tt>a2</tt>).
</p>

<h2>Manipulate alignments (merge and trim)</h2>

<p>
Alignments offer methods to manipulate these alignments. In
particular, it is possible to
<ul>
<li>clone alignments,</li>
<li>invert alignments (change the order of ontologies),</li>
<li>merge alignments (put all their correspondences together),</li>
<li>trim them under various threshold and threshold modalities.</li>
</ul>
</p>
	
<div class="fragment">
  // Merge the two results.
  ((BasicAlignment)a1).ingest(a2);

  // Threshold at various thresholds
</div>

<h2>Evaluating alignments</h2>

<p>
Alignments can also be evaluated. For that purpose, the API provides
the <tt>Evaluator</tt> interface. Similarly,
to <tt>AlignmentProcess</tt>, this interface is called by:
<ul>
<li>creating an instance of a particular <tt>Evaluator</tt> taking as
  argument a reference alignment and the alignment to evaluate;</li>
<li>processing the evaluation (<tt>eval()</tt>) eventually with a parameter.</li>
</ul>
</p>

<p>
Below the provided code first creates a parser for loading the
reference alignment, then creates an instance
of <tt>PRecEvaluator</tt> for computing precision and recall between
the alignment <tt>a1</tt> above with respects to the reference alignment.
<div class="fragment">
  // Evaluate them against the references
  // and choose the one with the best F-Measure
  AlignmentParser aparser = new AlignmentParser(0);
  Alignment reference = aparser.parse( (new File ( "refalign.rdf" ) ) . toURL() . toString());

  Evaluator evaluator = new PRecEvaluator( reference, a1 );
  Parameters p = new BasicParameters();
  evaluator.eval( p );
</div>
As previously, results are stored within the <tt>Evaluator</tt> object
and are accessed through specific accessors.
</p>

<p>
As an excercise, one could try to trim the alignment <tt>a1</tt> with
thresholds of 0., .2, .4, .6, .8, and 1., to evaluate these results
for precision and recall and to select the one with the best
F-measure.
</p>
<div class="button">
  <input type="button" onclick="show('qu5')" value="Show result"/>
  <input type="button" onclick="hide('qu5')" value="Hide result"/>
</div>
<div class="explain" id="qu5">
<pre>
  double best = 0.;
  Alignment result = null;
  for ( int i = 0; i <= 10 ; i += 2 ){
    a1.cut( ((double)i)/10 );
    evaluator = new PRecEvaluator( reference, a1 );
    evaluator.eval( p );
    System.err.println("Threshold "+(((double)i)/10)+" : "+((PRecEvaluator)evaluator).getFmeasure()+" over "+a1.nbCells()+" cells");
    if ( ((PRecEvaluator)evaluator).getFmeasure() > best ) {
       result = (BasicAlignment)((BasicAlignment)a1).clone();
       best = ((PRecEvaluator)evaluator).getFmeasure();
    }
  }
</pre>
</div>

<h2>Displaying an alignment</h2>

<p>
Finally, alignments can be displayed through a variety of formats
through the <tt>AlignmentVisitor</tt> abstraction. Alignment are
displayed by:
<ul>
<li>creating a <tt>PrintWriter</tt> in which the visitor will print,</li>
<li>creating the <tt>AlignmentVisitor</tt> on this writer, and</li>
<li>rendering the alignment (through the <tt>render()</tt> metthod).</li>
</ul>
</p>
<p>

<p>
For instance, it is possible to print on the standard output the
alignment selected at the previous exercise as a set of OWL axioms.
</p>
<div class="button">
  <input type="button" onclick="show('qu6')" value="Show result"/>
  <input type="button" onclick="hide('qu6')" value="Hide result"/>
</div>
<div class="explain" id="qu6">
<pre>
  // Displays it as OWL Rules
  PrintWriter writer = new PrintWriter (
		        new BufferedWriter(
	                 new OutputStreamWriter( System.out, "UTF-8" )), true);
  AlignmentVisitor renderer = new OWLAxiomsRendererVisitor(writer);
  result.render(renderer);
  writer.flush();
  writer.close();
</pre>
</div>

<h2>Putting these together</h2>
	
<p>Do you want to see a possible solution?</p>
<div class="button">
  <input type="button" onclick="show('qu7')" value="Cheat"/>
  <input type="button" onclick="hide('qu7')" value="Teacher is comming"/>
</div>
<div class="explain" id="qu7"><p>The main piece of code in Skeleton.java is replaced by:</p>
<pre>
  // Run two different alignment methods (e.g., ngram distance and smoa)
  AlignmentProcess a1 = new StringDistAlignment();
  params.setParameter("stringFunction","smoaDistance");
  a1.init ( onto1, onto2 );
  a1.align( (Alignment)null, params );
  AlignmentProcess a2 = new StringDistAlignment();
  a2.init ( onto1, onto2 );
  params = new BasicParameters();
  params.setParameter("stringFunction","ngramDistance");
  a2.align( (Alignment)null, params );

  // Merge the two results.
  ((BasicAlignment)a1).ingest(a2);

  // Threshold at various thresholds
  // Evaluate them against the references
  // and choose the one with the best F-Measure
  AlignmentParser aparser = new AlignmentParser(0);
  Alignment reference = aparser.parse( (new File ( "refalign.rdf" ) ) . toURL() . toString());
  Evaluator evaluator = new PRecEvaluator( reference, a1 );

  double best = 0.;
  Alignment result = null;
  Parameters p = new BasicParameters();
  for ( int i = 0; i <= 10 ; i += 2 ){
    a1.cut( ((double)i)/10 );
    evaluator = new PRecEvaluator( reference, a1 );
    evaluator.eval( p );
    System.err.println("Threshold "+(((double)i)/10)+" : "+((PRecEvaluator)evaluator).getFmeasure()+" over "+a1.nbCells()+" cells");
    if ( ((PRecEvaluator)evaluator).getFmeasure() > best ) {
       result = (BasicAlignment)((BasicAlignment)a1).clone();
       best = ((PRecEvaluator)evaluator).getFmeasure();
    }
  }
  // Displays it as OWL Rules
  PrintWriter writer = new PrintWriter (
		        new BufferedWriter(
	                 new OutputStreamWriter( System.out, "UTF-8" )), true);
  AlignmentVisitor renderer = new OWLAxiomsRendererVisitor(writer);
  a1.render(renderer);
  writer.flush();
  writer.close();
</pre></div>

<p>
This can be compiled and used through:
</p>
<div class="fragment">
$ javac -classpath ../../lib/align.jar:../../lib/procalign.jar -d results MyApp.java
$ java -cp ../../lib/Procalign.jar:results MyApp file://$CWD/myOnto.owl file://$CWD/edu.mit.visus.bibtex.owl > results/MyApp.owl
</div>

<p>The execution provides an insight about the best threshold:
<pre>
Threshold 0.0 : 0.4693877551020408 over 148 cells
Threshold 0.2 : 0.5227272727272727 over 128 cells
Threshold 0.4 : 0.5476190476190476 over 120 cells
Threshold 0.6 : 0.6478873239436619 over 94 cells
Threshold 0.8 : 0.75 over 72 cells
Threshold 1.0 : 0.5151515151515151 over 18 cells
</pre>
<p>
<p>A full working solution is <a href="MyApp.java">MyApp.java</a>.</p>

<div class="logic"><p><b>More work:</b> Can you add a switch like the <tt>-i</tt> switch of <tt>Procalign</tt> so that the main class of the application can be passed at commant-line.</p></div>

<div class="logic"><p><b>Advanced:</b> You can develop a specialized
    matching algorithm by <a href="index.html">subclassing the Java programs provided in
    the Alignment <abbr>API</abbr> implementation</a> (like BasicAlignment
    or DistanceAlignment).</p></div>

<div class="logic"><p><b>Advanced:</b> What about writing an editor for the alignment <abbr>API</abbr>?</p></div>
	
<h2>Further exercises</h2>
	
<p>More info: <a href="http://alignapi.gforge.inria.fr">http://alignapi.gforge.inria.fr</a></p>
	
<hr />
<small>
<div style="text-align: center;">http://alignapi.gforge.inria.fr/tutorial/tutorial3/embed.html</div>
<hr />
<div>$Id$</div>
</small>
</body>
</html>
